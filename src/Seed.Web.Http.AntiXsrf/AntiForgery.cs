using System;
using System.Web.Http.Controllers;
using Seed.Web.Http.AntiXsrf.Claims;

namespace Seed.Web.Http.AntiXsrf
{
    /// <summary>
    /// Provides access to the anti-forgery system, which provides protection against
    /// Cross-site Request Forgery (XSRF, also called CSRF) attacks.
    /// </summary>
    public static class AntiForgery
    {
        private static readonly AntiForgeryWorker Worker = CreateSingletonAntiForgeryWorker();

        private static AntiForgeryWorker CreateSingletonAntiForgeryWorker()
        {
            var serializer = new AntiForgeryTokenSerializer(MachineKey45CryptoSystem.Instance);
            var claimUidExtractor = new ClaimUidExtractor("", ClaimsIdentityConverter.Default);
            
            var tokenValidator = new TokenValidator(
                "__RequestVerificationToken",
                "XSRF-TOKEN",
                claimUidExtractor,
                null,
                false);

            return new AntiForgeryWorker(serializer, tokenValidator, true);
        }

        /// <summary>
        /// Generates an anti-forgery token pair (cookie and form token) for this request.
        /// This method is similar to GetHtml(), but this method gives the caller control
        /// over how to persist the returned values. To validate these tokens, call the
        /// appropriate overload of Validate.
        /// </summary>
        /// <param name="actionContext">The action context for the currently executing request.</param>
        /// <param name="oldCookieToken">The anti-forgery token - if any - that already existed
        /// for this request. May be null. The anti-forgery system will try to reuse this cookie
        /// value when generating a matching form token.</param>
        /// <param name="newCookieToken">Will contain a new cookie value if the old cookie token
        /// was null or invalid. If this value is non-null when the method completes, the caller
        /// must persist this value in the form of a response cookie, and the existing cookie value
        /// should be discarded. If this value is null when the method completes, the existing
        /// cookie value was valid and needn't be modified.</param>
        /// <param name="headerToken">The value that should be stored in the &lt;form&gt;. The caller
        /// should take care not to accidentally swap the cookie and form tokens.</param>
        public static void GetTokens(HttpActionContext actionContext, string oldCookieToken, out string newCookieToken, out string headerToken)
        {
            if (actionContext == null)
            {
                throw new ArgumentException(StringResources.HttpActionContextUnavailable);
            }

            Worker.GetTokens(actionContext, oldCookieToken, out newCookieToken, out headerToken);
        }

        /// <summary>
        /// Validates an anti-forgery token pair that was generated by the GetTokens method.
        /// </summary>
        /// <param name="actionContext">The context of the web request.</param>
        /// <param name="cookieToken">The token that was supplied in the request cookie.</param>
        /// <param name="headerToken">The token that was supplied in the request form body.</param>
        /// <remarks>
        /// Throws an HttpAntiForgeryException if validation fails.
        /// </remarks>
        public static void Validate(HttpActionContext actionContext, string cookieToken, string headerToken)
        {
            if (actionContext == null)
            {
                throw new ArgumentException(StringResources.HttpActionContextUnavailable);
            }

            Worker.Validate(actionContext, cookieToken, headerToken);
        }
    }
}
